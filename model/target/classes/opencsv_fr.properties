bean.instantiation.impossible=L''instantiation basique (sans paramètres) du bean demandé (ou d''un sous-bean créé récursivement) est impossible.
chronology.not.found=Aucune chronologie nommée ''%s'' n''a pu être trouvée.
collection.cannot.be.instantiated=Une collection de type [%s] ne peut être instanciée avec un constructeur sans paramètre.
column.count.mismatch=Le nombre de colonnes doit être égal au nombre des libellés d''en-têtes.
column.name.bogus=Les noms de colonnes ne peuvent être null, vides, ou composés uniquement d''espaces.
column.nonexistant=La colonne %s n''existe pas dans dans le jeu de données.
conversion.impossible=La conversion de %1$s vers %2$s a échoué.
csvdate.not.date=Annotation @CsvDate utilisée sur un champ de type incompatible (%s).
csvnumber.not.number=Annotation @CsvNumber utilisée sur un champ dont le type n''étend pas java.lang.Number.
csvreader.null=Instantiation de IterableCSVToBeanBuilder impossible: aucun CSVReader défini.
custom.converter.invalid=Erreur lors de l''instantiation du convertisseur personnalisé %s.
define.separator=Le caractère de séparation doit être défini.
error.introspecting.beans=Erreur lors de l''introspection du bean à écrire.
error.introspecting.field=Erreur lors de l''introspection de la propriété %1$s du bean %2$s.
error.writing.beans=Erreur irrécupérable lors de l''écriture de la liste des beans.
field.not.multivaluedmap=Le champ doit implémenter org.apache.commons.collections4.MultiValuedMap.
field.not.primitive=Le champ doit être d''un type primitif, wrapper de type primitif, BigDecimal, BigInteger ou String.
header.data.mismatch=Le nombre de champs de données ne correspond pas au nombre de colonnes d''en-tête.
header.data.mismatch.with.line.number=Erreur sur l''enregistrement %d: le nombre de colonnes de données n''est pas égal au nombre de colonnes d''en-tête. Attendu %d, a trouvé %d. 
header.error=Erreur lors de la lecture de l''en-tête CSV.
header.name.bogus=Les noms de colonnes d''en-tête ne peuvent être null, vides, ou composés uniquement d''espaces.
header.nonexistant=Pas de colonne pour l''en-tête [%s].
header.required.field.absent=En-tête manquant pour le champ [%s]. Liste des en-têtes trouvés [%s].
ignore.field.inconsistent=Lors de la spécification d''un champ à ignorer, le type et le champ doivent être non nulls, et le champ doit être membre du type, directement ou par héritage.
illegal.enum.value=La valeur [%1$s] n'est pas une valeur valide pour le type d'énumération %2$s. [Google Translate]
invalid.currency.value=[%1$s] n'est pas un code ISO 4217 valide.
invalid.collection.type=Le type spécifié pour la collection est inconnu, ou n''implémente pas java.util.Collection: %s.
invalid.date.format.string=Le format spécifié pour la chaîne de caractères n''est pas parsé correctement ou ne peut être utilisé avec les données fournies. Le format est : %s.
invalid.multivaluedmap.type=Le type spécifié pour la map est inconnu, ou n''implémente pas org.apache.commons.collections4.MultiValuedMap: %s.
invalid.number.pattern=Le pattern [%s] n''est pas valide d''après les règles de java.text.NumberFormat.
invalid.one.parameter.format.string=Le format spécifié pour la chaîne de caractères n''est pas valide pour le paramètre : %s
invalid.range.definition=La spécification d''intervalle [%s] est invalide.
invalid.regex=L''expression régulière spécifiée est invalide :%s.
map.cannot.be.instantiated=Une map multi-valuée de type [%s] ne peut pas être instanciée avec un constructeur sans paramètre.
matching=correspond à [%s]
multiline.limit.broken=Un enregistrment a plus de lignes que le maximum %d (ligne %d). Contexte : %s
multiple.required.field.empty=Les champs obligatoires suivants manquent d''un enregistrement :
no.converter.specified=Le convertisseur est obligatoire, mais n''a pas été spécifié.
numberformat.not.decimalformat=Un java.text.DecimalFormat est obligatoire dans @ConverterNumber, mais le JDK a renvoyé une autre implémentation de java.text.NumberFormat.
parsing.error=Erreur de parsing du CSV.
parsing.error.full=Erreur de parsing du CSV ligne: %1$d, valeur: %2$s
parsing.error.linenumber=Erreur de parsing du CSV ligne: %1$d. [%2$s]
read.only.iterator=L''itérateur est en lecture seule.
reader.null=Le Reader ne doit jamais être null.
recursion.binding.mutually.exclusive=Les annotations de récursion et de binding sont mutuellement exclusives.
recursion.on.primitive=La récursion ne peut pas s''appliquer sur les types primitifs.
recursive.type.encountered.twice=Le type %s a été rencontré plusieurs fois durant le mapping récursif.
regex.without.capture.group=L''expression régulière doit avoir au moins un groupe de capture : %s
required.field.empty=Le champ ''%s'' est obligatoire mais aucune valeur n''a été fournie.
special.characters.must.differ=Le séparateurs, caractère entourant les chaînes de caractères, et caractère d''échappement doivent être différents.
specify.strategy.reader=La stratégie de mapping et le CSVReader/Reader doivent être spécifiés.
strategy.type.missing=La stratégie de mapping ou le type de bean à renseigner doivent être spécifiés.
type.before.header=L''appel de MappingStrategy.setType() doit être effectué avant l''appel de MappingStrategy.generateHeader().
type.unset=Le type n''a pas été défini dans la stratégie de mapping.
unassignable.collection.type=L''implémentation de la collection (%s) ne peut pas être affectée au type de champ du bean (%s).
unassignable.multivaluedmap.type=L''implémentation de la map multi-valuée (%s) ne peut pas être affectée au type de champ du bean (%s).
unparsable.number=L''entrée [%1$s] n''a pas pu être parsée avec le pattern numérique [%2$s].
unterminated.quote=Champ non terminé à la fin de la ligne CSV. Début du texte : [%s]
validator.instantiation.impossible=Erreur d''instanciation du validateur %1$s pour le champ %2$s.
xmlgregoriancalendar.impossible=Impossible d''initialiser un XMLGregorianCalendar.
